# TCP/UDP基础知识

### 1.TCP特性

TCP是一种传输控制协议，建立于网络层(IP)的服务之上却与UDP截然不同，可以提供一种面向连接的、可靠的字节流服务。

TCP的可靠性依赖的方式：

1.应用程序的数据被分割成TCP认为的最适合发送的数据块。

2.有一个重传计时器，发出一个段"segment"后就会启动计时器，如果不能及时收到"ack"确认就会进行重传。

3.有一个"ack"报文段，用于进行确认。

4.TCP报文头包含一个checksum校验和选项。

5.TCP可以对收到的数据进行重新排序。

6.TCP可以丢弃重复的数据。

7.流量控制机制，连接的每一方都有固定大小的缓冲区。接收端只允许发送端发送接收端缓冲区能接纳的数据。



### 2.TCP报文格式

如下图所示就是TCP报文头的格式：

![1638347542470](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1638347542470.png)

首部长度可以看见是4位的，值应该是0 - 15。看整个报文，如果无选项字段则长度为 4Byte * 5 = 20Byte，这就是首部最小长度。所以长度字段反应报文首部长度的方式是 值 * 4。

因此首部最大长度是 15 * 4 = 60B。



### 3.TCP三次握手和四次挥手

如下图所示是一次典型的TCP建立连接和断开的过程。

![1638350558559](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1638350558559.png)

首先请求端发出一个SYN段表明想要建立连接，一个SYN标志会占用一个序号，其中1415531521是初始序号，括号中的0代表没带任何数据。还包含了选项字段的MSS最长报文大小，这个会在后续讲到。

然后服务器响应此请求，也会发回一个包含初始序列号的SYN报文段。同时发出ack对客户端进行确认，确认序号是刚刚请求端的初始序号加一的值。

最后请求端发回一个确认，可以看见确认值同样是服务器的初始序号加一。

可以用同样的方法对"四次挥手"进行分析。**四次挥手是由于TCP存在"半关闭"的状态**，TCP连接全双工的特性决定了需要分别进行关闭并且对方要进行确认。

细节一：

对于标志位，比如ack是不占用序号的，但如SYN，URG等会占用一位。我们这里有一个规则“ 凡是需要对端确认的，一定消耗TCP报文的序列号”。

细节二：

对于初始序号的选择，RFC标准文档其实有一个规定：将ISN看做一个计数器，每4ms加一。可以防止被延后的分组以后又被重复发送导致连接某一方对它做错误的解释。

另外，如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。而动态增长的 ISN 大大提高了猜测 ISN 的难度。

但在多数实现版本中并不严格按照上述规则实现，基本上初始序号选为1，然后每8ms加一。



### 4.TCP建立连接超时

观察下图(模拟服务器关闭tcp重连状态)：

![1641003513496](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641003513496.png)

可以看见第一个SYN和第二个SYN之间间隔将近6s，但后两者之间则几乎是稳定的24s。同时大多数伯克利系统都将建立一个新连接的最长时间限制为75s，超时则显示失败。

这些都和具体的实现机制有关。因为写起来比较繁琐，见下图：

![1641003758918](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641003758918.png)

总而言之，第一次超时时间不稳定就是因为第一次减第一个时钟滴答是可变的，无法保证正好过完一个滴答减一。



### 5.最大报文段MSS

MSS值只能在携带SYN标志的报文中出现，默认值为536Byte

一个较大的MSS可以防止数据分段，那么会提高效率。否则夸张一点 1Byte的数据配上20Byte的TCP头部和20Byte的IP头部，这传输效率就太感人。但数据包太大延时必然会较大，因此有一个合适的MSS是必要的。

当TCP发送一个SYN连接请求时，他会把MSS值设为外出接口上的MTU长度减去固定的IP和TCP首部长度。对于一个以太网，MSS值可以高达1460Byte。

可以看一个计算MSS的实例：

![1641005054616](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641005054616.png)

即使sun主机告知slip可以发送不超过1460Byte的数据，但由于slip知道自己的MTU为296，仍会选择发送不超过256Byte的数据以避免分段。



### 6.对'3'的详解和一些解惑*

1.为什么需要存在"半关闭"状态？

看下图：

![1641006918815](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641006918815.png)

我们在sun主机上执行命令"rsh bsdi sort < datafile"，意为令主机bsdi对来自datafile的数据进行排序。rsh的操作也在图中表示的较为清楚了，就是把datafile通过TCP连接传送给bsdi，并且排序结果通过TCP连接传回来。

诚然，sun主机将datafile的数据传给bsdi后就发送FIN了，表示我数据发完了。但显然不能两端都关闭，因为我还没接收到结果，因此需要这么一个”半关闭状态“，我这边发完了关闭了，但你可以继续发且我能收到。



2.TIME_WAIT状态，也即2MSL（Maximum Segment Lifetime 最大报文生存时间）等待状态。

![1641031093860](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641031093860.png)

如上图所示，当一端执行主动关闭并发回最后一个ack，该连接必须在TIME_WAIT状态停留2MSL的时间。这样可以让TCP发送最后的ack以防止此ack丢失。1MSL在RFC文档中定义为2分钟，但实现版本中有诸如30s、1min等。

3.2MSL期间的一些行为





### 7.复位报文段*

TCP首部中RST标志位就是“复位”标志。无论何时一个报文段建立“基准连接”发生错误TCP都会发出一个复位报文段。下面列举几种常见的情况：

1.目的端口可能未处于监听状态，我们称为“到不存在的端口的连接请求”。对于UDP会返回一个ICMP报文，对于TCP则使用我们说的复位报文段。

2.异常终止一个连接。我们知道正常终止连接依靠发送一个”FIN“标志符，但有时我们发送一个复位报文段来释放一个连接。RST报文中包含了序号和确认序号，另一端无需进行确认，收到的一方将终止连接通知应用层复位。

3.检测半打开连接。



### 8.同时打开与同时关闭

利用tcpdump查看一次“同时打开”的过程如下图所示：

![1641127148084](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641127148084.png)

bsdi主机8888端口和vangogh主机7777端口建立连接，两者都发送给对方SYN请求连接标志符，同时都发送ack进行确认。随后的 5 ~ 8 行是在进行通信，P代表了PSH标志位将消息直接发送给应用进程即使缓冲区未满。 9 ~ 12则是发送FIN断开连接。

显然的，从原先的三次握手变成了四次。

对于同时关闭，操作如下所示：

![1641129036130](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641129036130.png)

发送的报文数目同典型的“四次挥手”一致。



### 9.经受时延的确认

此例中，我们以一个Rlogin程序做试验。Rlogin程序客户端每次发送**一个字节**到服务器，服务器确认，并回显此字符，客户端最后进行确认。图示：

![1641351156781](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641351156781.png)

在下图中我们模拟了bsdi主机客户端和srv4服务器主机的一次通信过程，bsdi发送"date\n":

![1641351923387](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641351923387.png)



我们把由bsdi发送给srv4的ack都打上了星号"*"，标记为经受时延的确认。因为我们并不是在收到服务器返回的数据后立马发送ack的，所以称为"经受时延"。它往往推迟发送企图带上要发送的数据，称为"数据捎带ACK"。

绝大多数时延设定为200ms，但如果去观察上图中的时延(**带星号的括号里的就是时延**)的话会发现并不如此。但如果取出客户端发送"ACK"的实际时间，会发现这些时间的时差基本是200ms的整数倍。因为TCP软件使用了一个200ms的定时器，由于待确认的数据是随机到达的，TCP会在内核200ms的定时器下一次溢出时得到通知。

 **一般ACK延迟发送的时间为200ms，<u>但这个200ms并非收到数据后需要延迟的时间</u>。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。 这就可以解释，比如第一次因为溢出发送了第一个ACK(报文段3)，然后140 + 200 = 340，没有任何需要确认的340 + 200 = 540，此时有一个报文5待确认，自然就发送ACK(报文段6)。 140、200、340、540都是时间，140和540从图中观察，200是设定时延。**

而如果从srv4服务器端角度观察字符回显，我们的观察是从"客户端发送的一个字节 -> 服务器回显发送一个字节"，大致时间都是16ms，说明服务器的等待时间小于16ms，我们观察不到经受时延的ACK现象。因为服务器端的处理速度比较快，在定时器到时之前总是有数据需要发送（当然也有例外就是一个约16ms的等待时间越过了200ms边界）；因此，服务器端基本没有经受时延的ACK。



### 10.Nagle算法

刚刚看完的Rlogin，最后的数据报大小都是1Byte Data + 20Byte TCP+20Byte IP首部，我们称之为“微小分组”，在局域网上传输或许不会产生太大问题，但在低速广域网上则太多这样的分组很容易产生拥塞。

此算法的思想就是：在TCP连接上最多只允许存在一个未被确认的未完成的分组。[摘自他人blog](http://blog.chinaunix.net/uid-20767124-id-1849907.html)：

(1)发送端TCP将从应用进程接收到的第一数据块立即发送,不管其大小,哪怕只有一个字节.
(2)发送端输出第一块数据后开始收集数据,并等待确认.
(3)确认未达到时,若收集数据达到窗口的一半或一个MSS段,立即发送.
(4)确认到达后,把缓冲区中的数据组成一个TCP段,然后发送. 

根据上述思想，观察下面一个通信过程：

![1641393766999](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641393766999.png)

从客户端slip到服务器端vangogh发送的数据依次为1 1 2 1 2 2 3 1 3，和我们刚刚讲的rlogin 1Byte的通信仿佛有出入，但实际上就是因为那些发了2或3 Byte的数据报就是在等待服务器对上一个数据报ACK的同时不断在收集在缓冲区要发送的其他数据，等待收到ACK后，将这些1 Byte的数据集合起来当做一个TCP报文发送，符合Nagle。



### 11.关闭Nagle

编程时，使用标志符，TCP_NODELAY可以关闭Nagle算法。

下面这个从<<TCP/IP详解>>中摘抄出的例子能说明为何有时不需要Nagle算法：

在一个交互注册过程中键入终端的一个特殊功能键。这个功能键通常可以产生多个字符序列，经常从ASCII码的转义( escape )字符开始。如果TCP每次得到一个字符，它很可能会发送序列中的第一个字符（ASCII码的ESC），然后缓存其他字符并等待对该字符的确认。但当服务器接收到该字符后，它并不发送确认，而是继续等待接收序列中的其他字符。这就会经常触发服务器的经受时延的确认算法，表示剩下的字符没有在200 ms内发送。对交互用户而言，这将产生明显的时延。

通俗来说就是Nagle遇上了延迟ACK造成了时延可能无法令人满意：

假设执行"写->写->读"操作，客户端第一次写发送给了服务器。服务器执行了延迟ACK算法在等要返回的数据因此不会立马返回ACK，客户端执行Nagle算法，由于没立马接受到ACK则无法将第二次写的数据发送，造成时延。

一些可以关闭Nagle算法的场景：

 (1) 对端不向本端发送数据，并且对延时比较敏感的操作；这种操作没法捎带ack 。**[也就是说我们没必要为对端的延迟ACK算法负责，自顾自的发送完就好了]**

 (2)如上写-写-读操作；对于此种情况，优先使用其他方式，而不是关闭Nagle算法：

- --使用writev，而不是两次调用write，单个writev调用会使tcp输出一次而不是两次，只产生一个tcp分节，这是首选方法；
- --把两次写操作的数据复制到单个缓冲区，然后对缓冲区调用一次write；
- --关闭Nagle算法，调用write两次；有损于网络，通常不考虑；



### 12.窗口大小通告

可以返回去上面的图，有个"win"标志。服务器端基本是8192，客户端则为4096。

多数情况下服务器通告的窗口大小都为8192，因为服务器在读取并响应数据前并没有任何操作，而当服务器读取到客户端数据后基本会立马做出响应将数据发送出去。

反观客户端，当ACK到来时基本总有数据是待发送的，因为他在等待ACK过程中会缓存要发送的数据。但数据发送时客户便不再有机会读取服务器回显的数据，所以缓冲区还是会有一部分被占住。



### 13.滑动窗口

我们将根据下面这个可视化图来进行说明：

![1641433678391](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641433678391.png)

窗口变化的三种术语：

1.左边沿向右移动，称为“合拢”，通常是因为数据被发送和收到确认。

2.右边沿向右移动，称为“张开”，通常是因为另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。因为要是另一端不读取数据，数据一直在缓冲区内，他通告的窗口大小就会比较小，右边沿不动。

3.右边沿向左移动，称为“收缩”，RFC标准通常不支持这种情况。

![1641434646324](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641434646324.png)

四条小规律：

1.发送方不必发送一个全窗口大小的数据。

2.来自接收方的一个报文段确认数据并把窗口向右边滑动。这是因为窗口的大小是相对于确认序号的。

3.窗口大小可以减小，但几乎观察不到窗口右边沿左移的现象。

4.接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。



### 14.窗口大小

有研究表明，以太网上默认的4096字节并不是最理想的大小。将发送缓存和接收缓存都改为16384字节能增加约40%的吞吐量。



### 15.PUSH标志

目前的SOCKET API没有能够设置PUSH标志的操作，但多数伯克利实现版本都会自动地把那些已经发送出去的数据并且已经清空其缓存的报文段设PUSH标志符。

对于接收端，就更加没能力在处理报文的时候将其设置PUSH标志了，同时也没有任何API供我们检查某个报文段是否有PUSH标志。

有一些情况我们会看到一些不带任何数据的ACK报文段，但很多和窗口大小有关：

1.窗口张开时，需要一个窗口非0的ACK来重新启动。

2.许多TCP实现在窗口增加了两个最大报文段长度(MSS)或者最大可能窗口的50%时会发送窗口更新的报文段。



### 16.慢启动

前面好多例子都是发送端一开始就发送大量数据直到填充满接收方的窗口大小为止。同一局域网下这是可行的，但对于速率较慢的链路、包含了大量路由器的情况这不是一个非常聪明的方式。

"慢启动"为发送方的TCP增加了一个拥塞窗口(congestion window)。当与网络另一端的主机建立TCP连接后拥塞窗口初始化为1个报文段，每收到一个ACK就增加一个报文段。发送方取通告窗口(标志win)和拥塞窗口中的较小值作为发送上限。因此，拥塞窗口就是发送方的流量控制，通告窗口就是接收方的流量控制。

一开始初始化为1，收到ACK后为2。发送两个报文段并收到这两个报文段的ACK后拥塞窗口变为4，所以说慢开始是一个指数增长的过程。



### 17.拥塞和紧急方式URG*



### 18.超时与重传

观察书中给出的一个例子：

![1641482267678](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641482267678.png)

三次握手建立连接后，第一次发送14Byte的数据完全正常。但后面我们拔掉了服务器svr4的电缆可以看见bsdi主机尝试了多次重传，最后是发送给svr4一个RST复位标志。

单拎重传时间差来看是 1、3、6、12、24、48、64、64···实际上TCP将第一次超时重传时间设置为1.5s，但我们在前面定时器讲过，第一次数值减少会在第一个时钟滴答**(‘4’中的案例为500ms定时器)**的任意位置，所以最后测出来的时间应该是1~1.5的任意时间。而后就是翻倍直到64s，这叫做"指数退避"。

首次分组传输到发送复位信号之间的时间为9分钟，这个时间在TCP实现中是不可变的。

### 19.



# TCP服务器设计

大多数服务器进程是并发的，当一个新的连接请求到达服务器时，服务器接受这个请求并创建一个进程处理它。

### 1.服务器端口号

我们现在的服务器基本是多接口服务器，我们可以为每个接口配置一个ip地址，接下来将会以telnet为例：

![1641133842451](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641133842451.png)

首先我们观察无连接建立“Established”情况下的状态，可以看见本地地址为"*.23"，星号作为通配符表示可以从任何一个接口接收连接请求。而远端地址则表示目前未知，可以看见目前的状态是”监听状态“。

现在我们从slip主机启动客户端程序去连接服务器，启动两个，会变成如下状态：

![1641134242578](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641134242578.png)

这个本地地址就是slip主机通过以太网连接sun服务器接口配置的地址，远端客户地址也全部显示。

加入我们在solaries主机启动一个客户端程序通过SLIP链路与主机sun相连，会得到新结果如下：

![1641134342708](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641134342708.png)

可以看见本地ip地址变了，因为通过不同的接口进入主机。

### 2.限定的本地IP地址

如果我们指定服务器的本地IP地址，那么多接口将不能正常工作。

正如上面“1”所说的，只能接受对应接口进来的连接请求。(参考1中的图)比如我们配置服务器IP为“140.152.1.29”，那么solories主机仍能通过SLIP链路正常连接，但slip主机就不再能连接成功。

### 3.限定的远端IP地址

感觉意义并不是很大，见下图所示：

![1641135523276](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1641135523276.png)

### 4.呼入连接请求队列

虽然服务器基本是并发的，且可以创建新进程来处理连接请求。但难免有时候操作系统会忙于优先级更高的进程而无法创建这个新进程，此时我们要思考服务器应该如何处理到达的多个连接请求。

伯克利版本为此问题设计的规则：

1.等待请求一端(服务器)有一个固定长度的队列，该队列中的连接已被TCP接收但未被应用层接收。

2.应用层指明该队列的最大长度，为backlog"积压值"，取值范围基本是[0, 5]。

3.当一个SYN到达时，TCP使用算法根据当前连接队列的连接数决定是否接受这个连接。

4.如果连接队列还有空间则接收SYN并进行ACK确认，但应用层仅在第三个报文段收到后才知道此新连接。

5.如果没有空间，则不理会SYN。如果应用层不接受已经建立好的TCP连接，则客户主动打开最后超时。



# IP基础知识

#### 1.IP特性

IP是无连接、不可靠的。

不可靠指它不能保证IP数据报顺利到达目的地，它仅提供传输服务。

无连接则是指IP不维护任何后续数据报的信息，每个数据报都是独立的。

#### 2.IP报文格式

![1642583981769](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1642583981769.png)

IP 4Byte(32bit)在传输时，按照 0 - 7bit 、 8 - 15bit ····进行传输，称为"大端法"，也被叫做网络字节序。看过CSAPP应该知道"大端法"(在下图进行展示)，

![1642584425455](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1642584425455.png)

4bit版本号控制了我们当前是IPV4或是IPV6。4bit首部长度和TCP首部长度字段类似，也是记录的是报文中4Byte的数量，此长度最小为5，即IP最小长度是20Byte，最大则是60Byte。

服务类型字段可能遇到的比较少，具体内容如下图所示：

![1642586513687](C:\Users\user\AppData\Roaming\Typora\typora-user-images\1642586513687.png)



总长度字段指整个IP数据报的长度，



# 面经

就从自己的字节凉经开始！

#### 1.OSI七层网络模型及各层的作用。  ------>  自顶向下顺序

```c
1.应用层。这层的任务是通过应用进程交互完成特定网络应用。应用层协议是规定应用进程间通信交互的规则，这里的进程只运行在主机上的应用程序。对于不同的网络应用需要有不同的应用层协议。在互联网中的应用层协议有很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，等等。

2.表示层。使通信的应用程序能够解释交换数据的含义。这些服务包括数据压缩和数据加密（它们是自解释的）以及数据描述（这使得应用程序不必担心在各台计算机中表示/存储的内容格式不同的问题）。

3.会话层。会话层提供了数据交换定界和同步功能，包括了建立检查点和恢复方案的方法。
    
4.传输层。提供“端->端”的通信服务，应用层利用该服务传递应用层报文，这层主要包括了TCP和UDP协议。
    
5.网络层。主要功能是将网络层分组（数据报）从一台主机移动到另一台主机。在发送数据的时候，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。主要使用IP协议。
    
6.链路层。负责节点间网络层分组的传输，链路层分组为“帧”。
    
7.物理层。链路层的任务是将网络层的分组从一个网络节点传送至另一个，而物理层的作用则是将此分组中按照1bit进行传输。
```

#### 2.现代计算机网络采用的是更通用的“五层模型”。



#### 4.续上题，HTTP的加密过程。

```
1. 证书验证。 客户端发送证书请求，服务器返回一个包含公钥的证书，客户端验证此证书是否合法。
2. 交换秘钥。 使用非对称加密情况下，客户端用服务器公钥加密服务器端就用自己的私钥解密。反之同理，用客户端的秘钥进行相应的操作。
3. 交换数据。 使用秘钥进行加密然后再进行数据的交换。如下图所示是生成随机数后进行对称加密。
```

详情如下图所示：

 ![img](https://qqadapt.qpic.cn/txdocpic/0/b3288ea1a0faf4d9823f57dfc81f7995/0?w=800&h=777) 

#### 5.HTTP1.0和HTTP1.1的区别。

<u>*完全不会。。死记硬背。。*</u>

```
缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

带宽优化及网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

长连接：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
```

#### 6.



